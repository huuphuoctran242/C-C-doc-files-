DÆ°á»›i Ä‘Ã¢y lÃ  **checklist há»c Polymorphism (tÃ­nh Ä‘a hÃ¬nh) trong C++** Ä‘Æ°á»£c thiáº¿t káº¿ nhÆ° má»™t **lá»™ trÃ¬nh giáº£ng dáº¡y chuyÃªn sÃ¢u**, giÃºp báº¡n hiá»ƒu tá»« báº£n cháº¥t â†’ thá»±c hÃ nh â†’ Ã¡p dá»¥ng vÃ o dá»± Ã¡n thá»±c táº¿.

---

# âœ… **CHECKLIST Há»ŒC POLYMORPHISM TRONG C++ (Äáº¦Y Äá»¦ â€“ KHOA Há»ŒC â€“ CHUYÃŠN SÃ‚U)**

## **PHáº¦N A â€” Ná»€N Táº¢NG Cáº¦N Náº®M TRÆ¯á»šC (Prerequisites)**

1. Kiáº¿n thá»©c OOP cÆ¡ báº£n**

* Class, object â€“ cÆ¡ cháº¿ hoáº¡t Ä‘á»™ng bá»™ nhá»›
* Access modifiers: public, private, protected
* Constructor, destructor cÆ¡ báº£n (chÆ°a cáº§n virtual)

2. Con trá» & tham chiáº¿u trong C++**

* Con trá» cÆ¡ báº£n, dereference
* Con trá» Ä‘áº¿n object
* Tham chiáº¿u (reference) vÃ  reference binding
* Sá»± khÃ¡c nhau: pointer vs reference

---

# **PHáº¦N B â€” POLYMORPHISM TÄ¨NH (COMPILE-TIME / STATIC POLYMORPHISM)**

> Dáº¡ng Ä‘a hÃ¬nh khÃ´ng dÃ¹ng virtual â€“ compiler quyáº¿t Ä‘á»‹nh.

3. Function Overloading**

* Äá»‹nh nghÄ©a & nguyÃªn lÃ½
* CÃ¡c quy táº¯c overload: sá»‘ lÆ°á»£ng tham sá»‘, kiá»ƒu, thá»© tá»±
* Quy táº¯c **khÃ´ng** overload theo giÃ¡ trá»‹ tráº£ vá»
* Ambiguous overload â€“ lá»—i mÆ¡ há»“

4. Operator Overloading**

* ToÃ¡n tá»­ nÃ o overload Ä‘Æ°á»£c, toÃ¡n tá»­ nÃ o khÃ´ng
* Overload theo dáº¡ng member vs non-member
* Best practice khi overload: `operator<<`, toÃ¡n tá»­ so sÃ¡nh, toÃ¡n tá»­ sá»‘ há»c
* Quy táº¯c an toÃ n khi overload

---

# **PHáº¦N C â€” POLYMORPHISM Äá»˜NG (RUNTIME POLYMORPHISM)**

> Pháº§n quan trá»ng nháº¥t â€“ cá»‘t lÃµi cá»§a OOP C++.

5. Hiá»ƒu báº£n cháº¥t â€œRuntime Dispatchâ€**

* Lá»i gá»i hÃ m áº£o Ä‘Æ°á»£c quyáº¿t Ä‘á»‹nh á»Ÿ runtime
* Vai trÃ² cá»§a con trá»/ reference Ä‘áº¿n base class
* TrÃ¡nh hiá»ƒu sai: object slicing

6. Virtual Function (HÃ m áº£o)**

* CÃ¡ch khai bÃ¡o `virtual`
* CÆ¡ cháº¿ hoáº¡t Ä‘á»™ng: vTable â€“ vPtr
* Override chuáº©n (C++11): dÃ¹ng tá»« khÃ³a `override`
* Hidden vs override: khÃ¡c nhau tháº¿ nÃ o
* Final override (`final`) â€“ khi nÃ o dÃ¹ng

7. Pure Virtual Function & Abstract Class**

* Äá»‹nh nghÄ©a class trá»«u tÆ°á»£ng
* Pure virtual (`= 0`) hoáº¡t Ä‘á»™ng tháº¿ nÃ o
* Táº¡o interface báº±ng abstract class
* Quy táº¯c káº¿ thá»«a interface trong C++

8. Virtual Destructor**

* Khi nÃ o destructor cáº§n virtual
* Object bá»‹ delete qua con trá» base náº¿u khÃ´ng cÃ³ virtual â†’ lá»—i gÃ¬
* Pure virtual destructor â€“ táº¡i sao tá»“n táº¡i
* Triá»ƒn khai pure virtual destructor Ä‘Ãºng chuáº©n

---

# **PHáº¦N D â€” CÆ  CHáº¾ NÃ‚NG CAO Cá»¦A ÄA HÃŒNH**

9. Covariant Return Types (kiá»ƒu tráº£ vá» Ä‘á»“ng biáº¿n)**

* Base::func() tráº£ vá» Base*
* Derived::func() cÃ³ thá»ƒ tráº£ vá» Derived*
* Khi nÃ o nÃªn dÃ¹ng

10. Virtual Table nÃ¢ng cao**

* Tá»«ng object tháº­t sá»± chá»©a gÃ¬
* Vtable náº±m á»Ÿ Ä‘Ã¢u trong bá»™ nhá»›
* Gá»i hÃ m áº£o vá»›i nhiá»u cáº¥p káº¿ thá»«a
* Chi phÃ­ runtime cá»§a hÃ m áº£o

11. Multiple Inheritance & Polymorphism**

* Diamond problem & virtual inheritance
* Vtable trong multiple inheritance hoáº¡t Ä‘á»™ng ra sao
* Khi nÃ o khÃ´ng nÃªn dÃ¹ng

12. Polymorphism & Templates**

* Static polymorphism qua CRTP
* So sÃ¡nh: virtual (runtime) vs template (compile-time)
* Khi nÃ o chá»n cÃ¡i nÃ o

---

# **PHáº¦N E â€” THá»°C HÃ€NH Má»¨C CAO**

13. BÃ i táº­p thá»±c thi Ä‘a hÃ¬nh**

* Táº¡o hierarchy Ä‘á»™ng váº­t: Dog, Cat, Bird
* ThÃªm abstract class ISerializable
* Sá»­ dá»¥ng máº£ng con trá» base Ä‘á»ƒ quáº£n lÃ½ nhiá»u Ä‘á»‘i tÆ°á»£ng

14. á»¨ng dá»¥ng vÃ o dá»± Ã¡n nhá»**

* Bá»™ engine xá»­ lÃ½ shape: Circle, Rect, Triangle
* DÃ¹ng polymorphism Ä‘á»ƒ render
* Destructor pháº£i virtual
* DÃ¹ng abstract class Ä‘á»ƒ táº¡o plugin interface

15. Debug & tÆ° duy chuyÃªn sÃ¢u**

* DÃ¹ng debugger xem vtable pointer
* Kiá»ƒm tra kÃ­ch thÆ°á»›c object: sizeof vá»›i virtual vs khÃ´ng virtual
* Thá»­ xÃ³a object qua con trá» base + cÃ³ hoáº·c khÃ´ng `virtual` Ä‘á»ƒ tháº¥y lá»—i

---

# **PHáº¦N F â€” CÃ‚U Há»I KIá»‚M TRA KIáº¾N THá»¨C**

16. Bá»™ cÃ¢u há»i chuáº©n senior-level**

* Virtual function hoáº¡t Ä‘á»™ng tháº¿ nÃ o trong bá»™ nhá»›?
* Khi nÃ o destructor pháº£i lÃ  virtual?
* Pure virtual destructor lÃ  gÃ¬?
* Sá»± khÃ¡c biá»‡t giá»¯a override vÃ  overloading?
* Object slicing lÃ  gÃ¬?
* Táº¡i sao pointer/reference Ä‘áº¿n base má»›i dÃ¹ng Ä‘Æ°á»£c polymorphism?
* Covariant return type dÃ¹ng Ä‘á»ƒ lÃ m gÃ¬?
* So sÃ¡nh interface Java vs abstract class C++?
* Chi phÃ­ khi dÃ¹ng virtual function lÃ  gÃ¬?
* Template cÃ³ pháº£i lÃ  polymorphism khÃ´ng?

---

# Náº¿u báº¡n muá»‘n, mÃ¬nh cÃ³ thá»ƒ tiáº¿p tá»¥c:

âœ… Triá»ƒn khai tá»«ng má»¥c theo phong cÃ¡ch giáº£ng dáº¡y chi tiáº¿t
âœ… Viáº¿t code máº«u minh hoáº¡ cho tá»«ng má»¥c
âœ… Táº¡o 50 bÃ i táº­p luyá»‡n Ä‘a hÃ¬nh tá»« dá»… â†’ khÃ³
Báº¡n muá»‘n Ä‘i vÃ o má»¥c nÃ o trÆ°á»›c?



1. Äá»‹nh nghÄ©a: 
	+ Äa hÃ¬nh trong OOP lÃ  Ä‘áº·c tÃ­nh cho phÃ©p 1 phÆ°Æ¡ng thá»©c hoáº·c hÃ nh vi cÃ³ thá»ƒ hoáº¡t Ä‘á»™ng theo nhiá»u cÃ¡ch khÃ¡c nhau
	tÃ¹y thuá»™c vÃ o Ä‘á»‘i tÆ°á»£ng thá»±c thi. 
	
	+ VÃ­ dá»¥ má»™t ngÆ°á»i Ä‘Ã n Ã´ng cÃ³ thá»ƒ lÃ  nhÃ¢n viÃªn, cÅ©ng cÃ³ thá»ƒ lÃ  cha, lÃ  chá»“ng,....
	
	+ Äa hÃ¬nh cÃ³ 2 loáº¡i, Ä‘a hÃ¬nh run-time vÃ  Ä‘a hÃ¬nh compile time.
	
2. POLYMOPHISM TÄ¨NH - COMPILE TIME
	
	+ LÃ  Ä‘a hÃ¬nh quyáº¿t Ä‘á»‹nh á»Ÿ compile time. Compiler sáº½ gá»i Ä‘Ãºng hÃ m Ä‘á»ƒ gá»i khi biÃªn dá»‹ch.
	
	+ CÃ³ 2 dáº¡ng chÃ­nh: 
		- Function overloading
		- Operator overloading 
	 
	2.1 Function Overloading: 
		+ LÃ  cÃ¡c hÃ m cÃ¹ng tÃªn nhÆ°ng khÃ¡c danh sÃ¡ch tham sá»‘.
		+ Compiler sáº½ dá»±a trÃªn: sá»‘ lÆ°á»£ng, kiá»ƒu vÃ  thá»© tá»± tham sá»‘ Ä‘á»ƒ chá»n Ä‘Ãºng hÃ m.
		+ Compiler khÃ´ng phÃ¢n biá»‡t dá»±a trÃªn giÃ¡ trá»‹ tráº£ vá». 
		Chá»— nÃ y cáº§n miÃªu táº£ kÄ©, tá»©c lÃ  2 function overloading thá»±c táº¿ cÃ³ thá»ƒ cÃ³ kiá»ƒu tráº£ vá» 
		khÃ¡c nhau, tuy nhiÃªn thÃ¬ nÃ³ pháº£i cÃ³ tham sá»‘ khÃ¡c nhau. Náº¿u tham sá»‘ giá»‘ng há»‡t nhau mÃ  
		tráº£ vá» kiá»ƒu khÃ¡c nhau thÃ¬ khÃ´ng Ä‘Æ°á»£c coi lÃ  overload.
		
		VÃ­ dá»¥: 
			int foo(int x);
			double foo(double x); //ok
			double foo (int x); // error
		
		+ LÆ°u Ã½ khi sá»­ dá»¥ng: 
			- TrÃ¡nh lá»—i mÆ¡ há»“ báº±ng cÃ¡ch Ã©p kiá»ƒu rÃµ rÃ ng.
	
	2.2. Operator Overloading
		+ Háº§u háº¿t cÃ¡c toÃ¡n tá»­ Ä‘á»u cÃ³ thá»ƒ overload, ngoáº¡i trá»«: 
		
		. -> ToÃ¡n tá»­ truy cáº­p thÃ nh viÃªn class.
		
		.* -> Pointer to member operator: truy cáº­p con trá» trá» Ä‘áº¿n thÃ nh viÃªn cá»§a class.			 
			struct MyStruct {
				int x;
			};
			int main() {
				MyStruct obj{42};
				int MyStruct::*ptr = &MyStruct::x; // con trá» Ä‘áº¿n member x
				cout << obj.*ptr << endl; // Output: 42
			}

		? : -> ToÃ¡n tá»­ 3 ngÃ´i
		
		:: -> ToÃ¡n tá»­ phÃ¢n giáº£i pháº¡m vi
		
		sizeof
		
		typeid 
	
		+ CÃ³ 2 loáº¡i operator overloading Ä‘Ã³ lÃ  Member vÃ  None-member operator. 
		  Hiá»ƒu Ä‘Æ¡n giáº£n lÃ  1 loáº¡i lÃ  member cá»§a class, loáº¡i cÃ²n láº¡i thÃ¬ khÃ´ng. 
		  Dá»±a vÃ o cÃ¡c Ä‘iá»u kiá»‡n sau ta sáº½ quyáº¿t Ä‘á»‹nh xem toÃ¡n tá»­ ta muá»‘n overload 
		  nÃªn lÃ  loáº¡i nÃ o:
		  
		  - Member operator: Äá»‹nh nghÄ©a trong class, nháº­n this + tham sá»‘ náº¿u cáº§n.
		  - None-member operator: hÃ m Ä‘á»™c láº­p, thÆ°á»ng friend náº¿u cáº§n truy cáº­p biáº¿n private, protected.
		  
		  - Tráº£ vá» tham chiáº¿u &: 
			ThÆ°á»ng dÃ¹ng vá»›i toÃ¡n tá»­ dáº¡ng gÃ¡n vÃ o Ä‘á»‘i tÆ°á»£ng hiá»‡n táº¡i, thay Ä‘á»•i chÃ­nh this:
				=, +=, -=, ++ x, --, [], <<(cÃ¡i nÃ y Ä‘áº·c biá»‡t nha)
		
		  Tráº£ vá» tham trá»‹: 
			DÃ¹ng khi táº¡o giÃ¡ trá»‹ má»›i khÃ´ng pháº£i sá»­a báº£n gá»‘c:
				+, -, *, /, x++
				
		Thá»±c hÃ nh viáº¿t overload toÃ¡n tá»­: <<, cÃ¡c toÃ¡n tá»­ sá»‘ há»c, toÃ¡n tá»­ o sÃ¡nh
		
		class Vector {
		 private:
			int x;
			int y;
		 public:
			Vector(int x = 0,int y = 0): x(x),y(y){}
			Vector(const Vector& source):x(source.x),y(source.y){
				cout<<"Call copy constructor "<<endl;
			}
			// Overload operator=
			Vector& operator=(const Vector& source){
				cout<<"Call overload operator = "<<endl;
				x = source.x;
				y = source.y;
				return *this;
			}
			//Overload operator + (member)
			Vector operator+(const Vector& a) const{
				cout<<"Overload + "<<endl;
				Vector tmp(this->x + a.x, this->y+a.y);
				return tmp;
				
			}
			 //Overload operator + (none member)
			// friend Vector operator+(const Vector& a, const Vector& b){
			//     cout<<"Overload + (none member) "<<endl;
			//     Vector tmp(a.x +b.x,a.y+b.y);
			//     return tmp;
			// }
			
			//Overload operator+=
			Vector& operator+=(const Vector& a ){
				cout<<"Overload += "<<endl;
				this->x +=a.x;
				this->y +=a.y;
				return *this;
			}
			bool operator==(const Vector& a){
				return(this->x == a.x && this->y == a.y);
			}
			friend void Print(Vector& a){
				cout<<"x = "<<a.x<<"; y = "<<a.y<<endl;
			}
			friend ostream& operator<<(ostream& os, Vector& a){
				os<<"x : "<<a.x<<" ; y = "<<a.y<<endl;
				return os;
			}
			friend istream& operator>>(istream& is, Vector& a){
				is>>a.x>>a.y;
				return is;
			}
			friend bool operator==(const Vector& a, const Vector& b){
				return (a.x == b.x && a.y==b.y);
			}
		};
		int main(){
			Vector a;
			cin>>a;
			cout<<a;
			Vector b=a;//Copy constructor
			Vector c;
			c =b+a; //b.operator+(a) or operator+(a,b) sau Ä‘Ã³ c.operator=(tmp)
			c+=a; //c.operator+=(a);
			Print(c);
			cout<<c;
		}
	
	- Ta nÃªn viáº¿t triá»ƒn khai trÆ°á»›c Ä‘á»ƒ quyáº¿t Ä‘á»‹nh viáº¿t hÃ m overload nhÆ° tháº¿ nÃ o.
	VÃ­ dá»¥:
	a+ b -> a.operator+(b) -> Vector operator+(const Vector& b){
								  Vector tmp (this->x +b.x, this->y+b.y);
								  return tmp;
							  }
	a+b -> operator+(a,b) -> friend Vector operator+(const Vector&a,const Vector&b){
								Vector tmp(a.x + b.x, a.y+b.y);
								return tmp;
							 }
	c=b -> c.operator=(b) -> Vector& operator=(const Vector& b){
								this->x = b.x;
								this->y = b.y;
								return *this;
								}
								
=============================================================================================
ÄA HÃŒNH RUNTIME

1. Báº£n cháº¥t cá»§a Runtime Dispatch:
	- Runtime Dispatch: quyáº¿t Ä‘á»‹nh hÃ m nÃ o Ä‘Æ°á»£c gá»i á»Ÿ thá»i Ä‘iá»ƒm runtime. 
	- Xáº£y ra khi gá»i hÃ m áº£o thÃ´ng qua con trá» hoáº·c reference cá»§a lá»›p Base. 
	-> Ta cÃ³ thá»ƒ viáº¿t mÃ£ xá»­ lÃ½ chung thÃ´ng qua interface hay base type mÃ  hÃ nh vi thá»±c táº¿ 
	sáº½ phá»¥ thuá»™c vÃ o Object tháº­t cá»§a lá»›p Dáº«n xuáº¥t.

DÆ°á»›i Ä‘Ã¢y lÃ  **báº£n mÃ´ táº£ tuáº§n tá»± â€“ máº¡ch láº¡c â€“ logic** toÃ n bá»™ quÃ¡ trÃ¬nh runtime polymorphism trong C++, dÃ¹ng Ä‘á»ƒ lÃ m **tÃ i liá»‡u chuáº©n**.
(ÄÃ¢y lÃ  phiÃªn báº£n rÃµ rÃ ng nháº¥t theo trÃ¬nh tá»± thá»i gian cá»§a há»‡ thá»‘ng.)

---

# ğŸ“˜ **TOÃ€N Bá»˜ QUÃ TRÃŒNH RUNTIME POLYMORPHISM TRONG C++ â€“ MÃ” Táº¢ TUáº¦N Tá»°**

---

## **1. Compiler biÃªn dá»‹ch mÃ£ nguá»“n â†’ sinh mÃ£ mÃ¡y + cáº¥u trÃºc há»— trá»£ Ä‘a hÃ¬nh**

Khi báº¡n compile chÆ°Æ¡ng trÃ¬nh C++:

### **1.1 Compiler táº¡o mÃ£ mÃ¡y cho tá»«ng hÃ m**

* Táº¥t cáº£ hÃ m (ká»ƒ cáº£ virtual) Ä‘á»u Ä‘Æ°á»£c compile thÃ nh mÃ£ mÃ¡y.
* Má»—i hÃ m cÃ³ *Ä‘á»‹a chá»‰ cá»‘ Ä‘á»‹nh* trong binary.

### **1.2 Compiler táº¡o vTable cho má»—i class cÃ³ virtual function**

Vá»›i má»—i class chá»©a virtual function:

```
class Base
class Derived
```

Compiler táº¡o:

* Má»™t **vTable** chá»©a danh sÃ¡ch cÃ¡c **con trá» hÃ m** (function pointers)
* Má»—i vTable lÃ  **duy nháº¥t** cho tá»«ng class
* Entry tÆ°Æ¡ng á»©ng vá»›i thá»© tá»± khai bÃ¡o cÃ¡c hÃ m áº£o

VÃ­ dá»¥:

```
Base::vTable:
    [pointer -> Base::f]
    [pointer -> Base::g]

Derived::vTable:
    [pointer -> Derived::f]
    [pointer -> Derived::g]
```

### **1.3 Compiler thÃªm vPtr vÃ o object layout**

Náº¿u class cÃ³ virtual function â†’ compiler thÃªm **vPtr** á»Ÿ Ä‘áº§u object:

```
[ vPtr ]      --> pointer Ä‘áº¿n vTable
[ member x ]
[ member y ]
```

â†’ vPtr khÃ´ng pháº£i code báº¡n viáº¿t â€” compiler tá»± thÃªm.

---

## **2. Linker hoÃ n thiá»‡n chÆ°Æ¡ng trÃ¬nh â†’ táº¡o file executable**

Linker sáº½:

* Gá»™p code mÃ¡y
* Gá»™p vTable vÃ o RODATA segment
* GÃ¡n Ä‘á»‹a chá»‰ thá»±c cho vTable vÃ  cÃ¡c hÃ m

---

## **3. OS loader náº¡p chÆ°Æ¡ng trÃ¬nh vÃ o RAM**

Khi cháº¡y file thá»±c thi:

### **3.1 OS náº¡p cÃ¡c segment vÃ o RAM**

* **.text** â†’ mÃ£ mÃ¡y cá»§a hÃ m
* **.rodata** â†’ vTables
* **.data / .bss** â†’ biáº¿n global
* **heap** â†’ cáº¥p phÃ¡t Ä‘á»™ng
* **stack** â†’ Ä‘á»‹a phÆ°Æ¡ng & return addresses

### **3.2 CPU báº¯t Ä‘áº§u cháº¡y táº¡i hÃ m `main()`**

---

## **4. Táº¡o object â†’ constructor gÃ¡n vPtr**

Khi báº¡n viáº¿t:

```cpp
Base* p = new Derived();
```

### **4.1 Cáº¥p phÃ¡t object trÃªn heap**

Heap cáº¥p 1 block memory chá»©a:

```
[ vPtr ]
[ member variables cá»§a Derived ]
```

### **4.2 Constructor cá»§a Derived cháº¡y**

Compiler tá»± thÃªm code:

```
this->vPtr = &Derived::vTable;
```

â†’ ÄÃ¢y lÃ  bÆ°á»›c cá»±c ká»³ quan trá»ng:
**Object nÃ o thuá»™c class nÃ o â†’ vPtr trá» Ä‘áº¿n Ä‘Ãºng vTable cá»§a class Ä‘Ã³.**

---

## **5. Gá»i hÃ m áº£o (runtime dispatch)**

Khi gá»i:

```cpp
p->f();
```

Trong khi **p lÃ  `Base*` nhÆ°ng object tháº­t lÃ  `Derived`**.

### CPU thá»±c hiá»‡n:

### **BÆ°á»›c 1 â€” Láº¥y con trá» `p`**

```asm
mov rax, [p]
```

### **BÆ°á»›c 2 â€” Äá»c vPtr trong object**

```asm
mov rcx, [rax]      ; rcx = vPtr
```

### **BÆ°á»›c 3 â€” Truy cáº­p entry tÆ°Æ¡ng á»©ng trong vTable**

```asm
mov rdx, [rcx + OFFSET]    ; OFFSET = vá»‹ trÃ­ cá»§a hÃ m f trong báº£ng
```

### **BÆ°á»›c 4 â€” CALL Ä‘áº¿n hÃ m override**

```asm
call rdx
```

âœ Náº¿u object tháº­t lÃ  **Derived**, vPtr trá» Ä‘áº¿n **Derived::vTable**,
nÃªn CPU sáº½ gá»i **Derived::f()**.

â†’ ÄÃ¢y chÃ­nh lÃ  **runtime polymorphism**.
KhÃ´ng pháº£i compiler chá»n â€” **CPU chá»n vÃ o lÃºc cháº¡y dá»±a trÃªn vPtr**.

---

## **6. Táº¡i sao luÃ´n gá»i Ä‘Ãºng hÃ m override?**

VÃ¬:

* Má»—i object cÃ³ **vPtr riÃªng**
* vPtr luÃ´n trá» Ä‘Ãºng vTable cá»§a class tháº­t
* vTable chá»©a Ä‘Ãºng Ä‘á»‹a chá»‰ cá»§a hÃ m override

â†’ KhÃ´ng thá»ƒ gá»i nháº§m.

Ngoáº¡i lá»‡ duy nháº¥t: **object slicing**.

---

## **7. Khi delete object qua con trá» base**

Náº¿u báº¡n lÃ m:

```cpp
Base* p = new Derived();
delete p;
```

* CPU dÃ¹ng `Base`'s vTable Ä‘á»ƒ gá»i destructor
* Náº¿u destructor khÃ´ng virtual â†’ chá»‰ gá»i Base::~Base
  â†’ **rÃ² rá»‰ vÃ  undefined behavior**

---

## **8. TÃ³m táº¯t toÃ n bá»™ quÃ¡ trÃ¬nh trong 12 bÆ°á»›c**

DÃ¹ng lÃ m tÃ i liá»‡u:

1. Compiler phÃ¢n tÃ­ch class vÃ  hÃ m virtual.
2. Compiler táº¡o vTable cho tá»«ng class cÃ³ virtual.
3. Compiler thÃªm vPtr vÃ o object layout.
4. Linker há»£p nháº¥t vTable vÃ  mÃ£ mÃ¡y.
5. ChÆ°Æ¡ng trÃ¬nh Ä‘Æ°á»£c táº¡o thÃ nh file executable.
6. OS loader náº¡p code + vTables vÃ o RAM.
7. CPU báº¯t Ä‘áº§u cháº¡y táº¡i `main()`.
8. Gá»i `new Derived()` â†’ heap cáº¥p phÃ¡t bá»™ nhá»›.
9. Constructor cá»§a Derived gÃ¡n vPtr = Derived::vTable.
10. Khi p->f() â†’ CPU láº¥y vPtr tá»« object.
11. CPU truy cáº­p vTable â†’ láº¥y Ä‘Ãºng function pointer.
12. CPU `call` Ä‘Ãºng hÃ m override â†’ runtime polymorphism xáº£y ra.

---

2. Virtual Function:
	- HÃ m áº£o lÃ  hÃ m Ä‘Æ°á»£c khai bÃ¡o virtual trong class base vÃ  cho phÃ©p lá»›p dáº«n xuáº¥t cÃ³ thá»ƒ override láº¡i. 

+ VTable vÃ  VPointer
	- VTable: Ä‘iá»u Ä‘áº§u tiÃªn cáº§n hiá»ƒu lÃ  Vtable thuá»™c vá» Class.
		+ Class cÃ³ vtable khi: 
			- CÃ³ Ã­t nháº¥t 1 virtual function hoáº·c pure virtual function.
			- lÃ  class káº¿ thá»«a tá»« 1 class khÃ¡c cÃ³ virtual function.
		+ Vtable chá»©a cÃ¡c function pointer, hay nÃ³i cÃ¡ch khÃ¡c lÃ  con trá» trá» Ä‘áº¿n Ä‘á»‹a chá»‰ cá»§a cÃ¡c hÃ m Ä‘Æ°á»£c 
			override gáº§n nháº¥t. CÃ¡i nÃ y hÆ¡i khÃ³ hiá»ƒu, kiá»ƒu nhÆ° class Cha cÃ³ 3 hÃ m x, y, z virtual thÃ¬ Vtable cá»§a Cha
			chá»©a function pointer trá» Ä‘áº¿n Ä‘á»‹a chá»‰ 3 tháº±ng nÃ y. Class Con cÃ³ 2 hÃ m x,y override láº¡i cá»§a cha cÃ²n z thÃ¬
			khÃ´ng, lÃºc nÃ y Vtable cá»§a Con chá»©a 2 function pointer trá» Ä‘áº¿n 2 hÃ m x,y Ä‘Ã£ override vÃ  1 function pointer
			trá» Ä‘áº¿n hÃ m z cá»§a lá»›p cha.
			
		class OngNoi{
		  public:
			virtual void function_1(){
				cout<<"Function 1 cua Ong noi"<<endl;
			}
			virtual void function_2(){
				cout<<"Function 2 cua Ong noi"<<endl;
			}
			virtual void function_3(){
				cout<<"Function 3 cua Ong noi"<<endl;
			}
		};

		class Cha : public OngNoi{
		 public:
			void function_1() override{
				cout<<"Function 1 cua Cha"<<endl;
			}
		};
		class Con : public Cha{
		 public:
			void function_2() override{
				cout<<"Function 2 cua Con"<<endl;
			}
		};
		int main(){
			OngNoi* a = new OngNoi();
			OngNoi* b = new Cha();
			OngNoi* c = new Con();
			
			a->function_1();
			a->function_2();
			a->function_3();
			
			b->function_1();
			b->function_2();
			b->function_3();
			
			c->function_1();
			c->function_2();
			c->function_3();  
			delete a;
			delete b;
			delete c;
		}
		
		Function 1 cua Ong noi
		Function 2 cua Ong noi
		Function 3 cua Ong noi
		
		Function 1 cua Cha
		Function 2 cua Ong noi
		Function 3 cua Ong noi
		
		Function 1 cua Cha
		Function 2 cua Con
		Function 3 cua Ong noi
		
	- VPointer: LÃ  1 con trá» áº©n Ä‘Æ°á»£c compiler thÃªm vÃ o cÃ¡c object tÆ°Æ¡ng á»©ng vá»›i class cÃ³ Vtable.
		Khi biÃªn dá»‹ch nÃ³ sáº½ Ä‘Æ°á»£c thÃªm vÃ o trÆ°á»›c cÃ¡c member cá»§a object (dá»©ng Ä‘áº§u).
		Vptr sáº½ trá» Ä‘áº¿n Vtable cá»§a class tÆ°Æ¡ng á»©ng vá»›i object chá»©a nÃ³. Hay nÃ³i cÃ¡ch khÃ¡c Vptr thuá»™c 
		object cÃ²n Vtable thuá»™c class. Vptr cá»§a cÃ¡c obj cÃ¹ng loáº¡i sáº½ trá» Ä‘áº¿n cÃ¹ng 1 Vtable.

3. Virtual Destructor: 
	- Khi delete 1 object thÃ´ng qua con trá» base, ta cáº§n cÃ³ Virtual destructor Ä‘á»ƒ destructor cá»§a lá»›p 
	Dáº«n xuáº¥t Ä‘Æ°á»£c gá»i trÆ°á»›c. Náº¿u khÃ´ng cÃ³ nÃ³ sáº½ khÃ´ng Ä‘Æ°á»£c gá»i. 
	Náº¿u destructor khÃ´ng virtual vÃ  báº¡n delete basePtr mÃ  basePtr trá» tá»›i Derived, gá»i destructor chá»‰ cá»§a Base
	â€” dáº«n Ä‘áº¿n undefined behavior (thÆ°á»ng lÃ  rÃ² rá»‰ bá»™ nhá»›, khÃ´ng giáº£i phÃ³ng thÃ nh pháº§n Derived, hoáº·c há»ng tráº¡ng thÃ¡i)
	
4. Tá»« khÃ³a Override:
	- GIÃºp Ä‘áº£m báº£o ráº±ng phÆ°Æ¡ng thá»©c thá»±c sá»± ghi Ä‘Ã¨ phÆ°Æ¡ng thá»©c lá»›p cÆ¡ sá».
	- Náº¿u cÃ³ sai sÃ³t nhÆ° khÃ¡c tham sá»‘, khÃ¡c kiá»ƒu tráº£ vá» trÃ¬nh biÃªn dá»‹ch sáº½ bÃ¡o lá»—i
	
	- NguyÃªn táº¯c vÃ ng khi Override: Chá»‰ khi signature cá»§a hÃ m trÃ¹ng khá»›p 100% thÃ¬ override má»›i xáº£y ra:
		+ TÃªn hÃ m
		+ Danh sÃ¡ch tham sá»‘
		+ CÃ³ const hay khÃ´ng cÅ©ng pháº£i Ä‘á»“ng nháº¥t.
		+ Return type (trá»« trÆ°á»ng há»£p covariant: method Base tráº£ vá» Base*, methob class con cÃ³ thá»ƒ tráº£ vá» Derived*
	
5. Tá»« khÃ³a Final: 
	- DÃ¹ng vá»›i function:
		virtual void function_1() final{}
		-> Chá»‘ng ghi Ä‘Ã¨
	DÃ¹ng vá»›i Class:
	
		class A final {
		 public:
			void function(){}
		}
		-> Chá»‘ng káº¿ thá»«a.