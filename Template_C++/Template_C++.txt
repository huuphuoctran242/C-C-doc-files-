 Checklist học Template C++ từ A → Z
1. Kiến thức nền tảng trước khi học Template

 Hiểu rõ hàm và class trong C++.
 Hiểu về overloading và polymorphism.
 Nắm vững compile-time vs runtime.


2. Template cơ bản

 Function Template

Cú pháp: template<typename T> T add(T a, T b);
Hiểu cách compiler tạo phiên bản hàm cho từng kiểu.


 Class Template

Cú pháp: template<typename T> class MyClass {};
Hiểu cách tạo đối tượng với nhiều kiểu khác nhau.


 Template Parameters

Kiểu dữ liệu (typename hoặc class).
Giá trị không phải kiểu (non-type template parameter): template<int N>.


 Default Template Arguments.


3. Template nâng cao

 Specialization

Full specialization: Viết riêng cho một kiểu cụ thể.
Partial specialization: Viết cho một nhóm kiểu.


 Template Overloading.
 Variadic Templates (C++11): template<typename... Args>.
 Fold Expressions (C++17).


4. Template và Compile-time

 Hiểu instantiation: Compiler tạo code cụ thể từ template.
 Hiểu SFINAE (Substitution Failure Is Not An Error).
 Type Traits (C++11): std::is_same, std::enable_if.
 constexpr + template (C++14/17).


5. Template trong thực tế

 Template với STL: std::vector<T>, std::map<Key, Value>.
 Template với Smart Pointer: std::shared_ptr<T>.
 Template trong Generic Programming.
 Template trong Design Patterns (Factory, Singleton).


6. Template nâng cao (C++20 trở lên)

 Concepts: Ràng buộc kiểu trong template.
 Requires Clause.
 Ranges và Template.


7. Thực hành

 Viết function template cho toán tử cộng/trừ.
 Viết class template cho Stack hoặc Queue.
 Viết variadic template cho hàm print(...).
 Áp dụng SFINAE để kiểm tra kiểu.
 Viết một factory template giống như process_e2e_profile.
 
 
 =======================================================================
 1. Function Template: 
 - Hiểu đơn giản là viết 1 hàm với kiểu dữ liệu tổng quát, sử dụng được với nhiều kiểu dữ liệu khác nhau 
 mà không cần viết lại hàm cho từng kiểu. 
 
	template<typename T>
	T Max(T& a, T& b){
		return (a>b)? a : b;
	}
	int main(){
		int x = 4;
		int y = 5;
		//int z = Max(x,y); 
		int z = Max<int>(x,y); // chỉ định kiểu dữ liệu rõ ràng
		cout<<z<<endl;
	}
	Nếu ta gọi: Max(1,5.5) -> Compiler sẽ không suy ra được kiểu -> Lỗi
	Trừ khi ta chỉ đích danh kiểu: 
	
	template<typename T>
	T Max(T a, T b){
		return (a>b)? a : b;
	}
	int main(){
		int z = Max<int>(2,5.5); // chỉ định kiểu dữ liệu rõ ràng
		cout<<z<<endl;
	}
	
	
	+ Compiler làm gì khi dùng function template (template instantiation)
	
		- Điều quan trọng đầu tiên là compiler không sinh ra code cho template khi bạn viết template.
		Nghĩa là nếu chỉ định nghĩa template thì nó chỉ như 1 công thức dùng trước khi biên dịch thành mã máy,
		sẽ không tạo ra code máy.
		- Khi bạn gọi hàm này và truyền kiểu dữ liệu tương ứng, thì các hàm này mới được biên dịch thành mã máy. 
			
			template<typename T>
			T add(T a, T b) { return a + b; }
			
			Khi executable được load vào RAM, code segment chứa:
				Machine code của add<int>
				Machine code của add<double>
				… các instantiation khác bạn đã dùng
			KHÔNG có:
				Tên template
				Cấu trúc template
				Biểu thức template
				Bất kỳ thứ gì liên quan đến “generic version”
				Vì tất cả template đã biến mất sau compile-time.
	
	+ Quá trình xử lý tuần tự của Compiler như sau:
		- Bước 1: Đọc function template, ghi nhớ khuôn mẫu và không sinh ra code.
		- Bước 2: Gặp lệnh gọi hàm template:
			+ Compiler tự suy luận kiểu
		- BƯớc 3: Compiler thay thế T bằng int và tạo 1 hàm mới. Biên dịch thành mã máy. 
		- Bước 4: Lặp lại cho tất cả các hàm template được gọi. 
		
	+ So sánh giữa Template và Overloading:
		- Hiểu đơn giản thì 2 cái này khác nhau. Overload là ta tự định nghĩa các hàm cùng tên nhưng khác
		tham số. Nghĩa là compiler sẽ biên dịch tất cả ra mã máy. Chứ không tự gen ra code như template.
		
2. Class template:
	
	template <typename T>
	class Box {
		T value;
		Box(T v):value(v){}
		T get_value(){return value;}
	}
	-> Đây chỉ là 1 mẫu class chứ không phải là 1 class. 
	Với template này ta có thể tạo ra được nhiều class cùng tên nhưng hoàn toàn tách biệt với nhau về cả 
	layout và bộ nhớ ( có static thì cũng là static riêng) Nói chung là không liên quan gì đến nhau hết.
	
	Box<int> là 1 class
	Box<double> là 1 class khác
	.....
	Compiler sẽ tạo ra các vùng mã riêng biệt (Thay thế T bằng kiểu dữ liệu tương ứng)
	
3. Template Parameters:
	Là tham số để compiler sinh ra code mới tainj compile-time. Hiểu đơn giản thì những ví dụ từ trên lúc nãy
	cũng là 1 kiểu template parameter, ở đây là Type parameter: tham số kiểu.
	Nói chung là sẽ có 2 loại:
	+ Type parameter
	+ None type parameter.
	
	1. Type parameter: Chính là các kiểu phía trên mà mình đã lấy ví dụ. 
	cú pháp: 
		template<typename T> hoặc template<class T>
		Sau đó ta định nghĩa function hoặc class.
		-> khi gặp lời gọi hàm hoặc khai báo object, compiler sẽ tạo ra function và class với kiểu tương ứng.
		
	2. None type parameter: Cái này thì nó lạ hơn và cần tìm hiểu kĩ. 	
		template<int N>
		struct Array{
			int data[N];
		};
		
		Khi dùng Array<5> a; => a.data là mảng 5 phần tử. Ở đây Array<5> là 1 kiểu struct luôn nha. 
		Ở đây ta cần lưu ý None type parameter phải là 1 compile-time variable. 
		Nghĩa là compiler phải biết giá trị của N tại thời điểm compile.
		
****** Ở đây ta sẽ làm rõ như thế nào là compile-time variable và runtime variable.
	+ Compile-time variable: Literal (10,20,'A', true,....), const, enum. 
		Đặc biệt lưu ý giữa: 
			constexpr int x = 10; -> Chắc chắn biết giá trị tại compiler-time
			const int x = 10;     -> Chưa chắc, nếu viết như kia thì ok, nhưng viết const int x = get_value()
			với hàm trên lấy giá trị từ bàn phím thì lại không phải Compile-time variable
			
	+ Runtime variable: Các biến được lưu ở RAM, có thể thay đổi giá trị.
	
	Tóm lại là dùng cũng giống nhau:
	Array<5> ≠ Array<6>   (hai class khác nhau)
	Box<int> ≠ Box<double> (hai class khác nhau)
	
	+ Ta có thể sử dụng nhiều loại tham số:
	
	template<typename T, int N>
	class StaticArray {
	public:
		T data[N];
	};

	StaticArray<int, 10> arr1;
	StaticArray<double, 20> arr2;

========================================================================
Dưới đây là **20 câu hỏi** giúp bạn tự kiểm tra và nắm chắc kiến thức về **C++ Templates** — từ cơ bản đến nâng cao. Mình cố tình viết theo hướng “tự hỏi – tự trả lời”, rất phù hợp để ôn thi hoặc luyện phỏng vấn.

---

# ✅ **20 CÂU HỎI VỀ TEMPLATE C++ (kèm hướng dẫn bạn cần nắm được)**

## **1. Template là gì? Dùng để giải quyết vấn đề gì trong C++?**

*Bạn cần hiểu bản chất: cơ chế sinh mã (code generation), generic programming.*

---

## **2. template<class T> và template<typename T> khác nhau không?**

---

## **3. Khi nào diễn ra quá trình instantiation của template?**

*Compile-time hay link-time? Khi nào compiler generate code?*

---

## **4. Template parameter T là gì? Vai trò của nó trong generic class/function?**

---

## **5. Non-type template parameter (NTTP) là gì? Cho ví dụ.**

---

## **6. Tại sao NTTP phải là giá trị có thể xác định tại compile-time?**

*Ví dụ: int x = 5; ok? int y; template<int N> foo<y>(); lỗi?*

---

## **7. Các kiểu dữ liệu được phép dùng làm NTTP?**

*C++17 và C++20 có gì khác nhau?*

---

## **8. Template specialization là gì? Dùng khi nào?**

*Phân biệt partial và full specialization.*

---

## **9. Full specialization khác gì với overload?**

*Trả lời đúng cho thấy bạn hiểu bản chất template based dispatch.*

---

## **10. Partial specialization là gì? Nó có áp dụng cho function template không?**

---

## **11. SFINAE là gì? Khi nào xảy ra?**

*(Substitution Failure Is Not An Error)*

---

## **12. Làm sao dùng SFINAE để giới hạn template cho kiểu số học (int, float…)?**

---

## **13. Template function có thể suy luận kiểu T không? Khi nào phải ghi rõ T?**

---

## **14. Biến template (variable template) là gì? Dùng vào việc gì? (C++14+)**

---

## **15. Template alias (using alias template) là gì?**

---

## **16. Khái niệm dependent name là gì? Tại sao cần từ khóa typename trong 1 số trường hợp?**

---

## **17. Nếu class template có static member thì các instance của template có dùng chung bộ nhớ không?**

*Map<bool> và Map<int> có chia sẻ cùng static?*

---

## **18. Template có thể tách file .h / .cpp không? Tại sao hầu như phải đặt trong header?**

---

## **19. Concept (C++20) khác gì với SFINAE khi ràng buộc template?**

---

## **20. Khi compiler chọn giữa nhiều template overload, nó dựa theo quy tắc nào?**

*Template overload resolution, deduction ranking.*

